% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph_auction.R
\name{auction_match}
\alias{auction_match}
\alias{graph_auction}
\title{Graph matching method by auction algorithm}
\usage{
auction_match(
  A,
  B,
  seeds = NULL,
  similarity = NULL,
  dmat,
  compensate = TRUE,
  type = "OSPA1",
  edge_weighted = FALSE,
  CV = 1,
  CE = 1,
  vpen = 1,
  m = nrow(A[[1]]),
  n = nrow(B[[1]]),
  stop_at = 1,
  maxiter = 100,
  lang = c("Cpp", "R"),
  eps = 0.01,
  verbose = 0
)

graph_auction(
  A,
  B,
  seeds = NULL,
  similarity = NULL,
  dmat,
  compensate = TRUE,
  type = "OSPA1",
  edge_weighted = FALSE,
  CV = 1,
  CE = 1,
  vpen = 1,
  m = nrow(A[[1]]),
  n = nrow(B[[1]]),
  stop_at = 1,
  maxiter = 100,
  lang = c("Cpp", "R"),
  eps = 0.01,
  verbose = 0
)
}
\arguments{
\item{A}{A matrix, igraph object, or list of either.}

\item{B}{A matrix, igraph object, or list of either.}

\item{seeds}{A vector of integers or logicals, a matrix or a data frame. If
the seed pairs have the same indices in both graphs then seeds can be a
vector. If not, seeds must be a matrix or a data frame, with the first
column being the indices of \eqn{G_1} and the second column being the
corresponding indices of \eqn{G_2}.}

\item{similarity}{A matrix. An \code{n-by-n} matrix containing vertex
similarities. Mandatory for the "IsoRank" method.}

\item{dmat}{A matrix. An n x n matrix that contains vertex differences.}

\item{compensate}{Logical. Whether or not the computation of the value of a new assignment in the \code{auction_match} algorithm also
considers influences of this new assignment to other bidders and objects. Default is \code{compensate = TRUE}.}

\item{type}{One of \code{"OSPA1"}, \code{"OSPA2"} and \code{"TT"} determining the variant of the distance
used. See details.}

\item{edge_weighted}{Whether the graphs have edge_weights. Defaults to \code{FALSE}.}

\item{CV}{An upper bound for the vertex distance in the OSPA distances. Default is \code{CV = 1}.}

\item{CE}{An upper bound for the edge distance in the OSPA distances. Default is \code{CE = 1}.}

\item{vpen}{A penalty for adding auxiliary vertices in the TT distance. Default is \code{vpen = 1}.}

\item{m}{The initial size of the graph \code{g1}. Default is \eqn{m = nrow(A[[1]])}.}

\item{n}{The initial size of the graph \code{g2}. Default is \eqn{n = nrow(B[[1]])}.}

\item{stop_at}{Maximal number of full assignments that can be reached before the auction algorithm stops. Default is \eqn{stop_at = 1}.}

\item{maxiter}{Maximal number of iterations that can be reached before the auction algorithm stops. Default is \eqn{maxiter = 100}.}

\item{lang}{One of "Cpp" and "R". Specifies whether the C++ or R implementation is called. The C++-implementation is usually much faster.}

\item{eps}{Small constant that is added to differences of personal values in the auction algorithm. Only relevant for method \code{"auction_match"}. Default is \code{eps = 0.01}.}

\item{verbose}{Numerical. How much information on intermediate results should be printed during the algorithm. The larger verbose the more information is printed. Default is \code{verbose = 0}.}
}
\value{
A  \code{\link[iGraphMatch]{graphMatch}} object.
}
\description{
Find the optimal matching w.r.t. a assignment based metric of two given graphs (of the same size)
sing an auction algorithm. \code{graph_auction} is an alias for \code{auction_match} that is deprecated
and will be removed in future versions.
}
\details{
The function \code{auction_match} approximates an optimal matching for two graphs of the same size by performing
an heuristic auction algorithm.

The graphs passed by the \code{\link[iGraphMatch]{gm}} function are already extended to graphs of the same size, see also \code{\link{gmspat}}.
To find the optimal matching w.r.t. the given \code{type} the initial graph sizes need to be passed via \code{m} and \code{n}.

In each iteration the personal object values of a bidder are calculated. These values depend on the chosen \code{type}
and if \code{compensate = TRUE} also the influence of a possible new assignment of the current bidder to the current object to other bidders
and objects (for example due to un-assignment) is considered.

An iteration is done if every bidder got the chance to bid. A full assignment is reached if every bidder is assigned to an object.
If the number of iterations is \eqn{\geq maxiter} or the number of full assignments is \eqn{\geq stop_at} the algorithm stops
and returns the best full assignment.
}
